## 4.创建线程的两种方式分别是什么？各有什么优缺点？
```
继承Thread类 
优势：编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程 
劣势：因为线程类已经继承了Thread类，所以不能再继承其他父类。 
实现Runable接口 
优势：（1）线程类只是实现了Runnable接口与Callable接口，还可以继承其他类。 
     （2）在这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、
        代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 
劣势：编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。  
```
## 5.请你简述sleep( )和wait( )有什么区别？
```
sleep() 属于Thread类，线程遇到他表示的是线程暂停一定的时间，而其他线程运行，
这其中不会释放锁对象，而到了一定的时间被暂停的线程又会自动恢复运行状态。
wait() 属于Object类，线程遇到他时，表示线程会放弃对象锁，进入等待此对象的等待锁定池，
只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
```
## 6.Java中实现线程通信的三个方法及其作用？
```
1、传统的线程通信。
在synchronized修饰的同步方法或者修饰的同步代码块中使用Object类提供的wait(),notify()和notifyAll()3个方法进行线程通信
wait():导致当前线程等待，直到其他线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程。
notify():唤醒在此同步监视器上等待的单个线程。
notifyAll():唤醒在此同步监视器上等待的所有线程。

2、使用Condition控制线程通信。
当程序使用Lock对象来保证同步，系统不存在隐式的同步监视器，只能用Condition类来控制线程通信。
await():类似于隐式同步监视器上的wait()方法，导致当前线程等待，直到其他线程调用该Condition的signal()方法或signalAll()方法来唤醒该线程。
signal():唤醒在此Lock对象上等待的单个线程。如果所有的线程都在该Lock对象上等待，则会选择唤醒其中一个线程。选择是任意性的。
signalAll():唤醒在此Lock对象上等待的所有线程，只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的线程。

3、使用阻塞队列（BlockingQueue）控制线程通信（也实现了生产者消费者模式）
put(E e):尝试把E元素放入BlockingQueue中，如果该队列的元素已满，则阻塞该线程。
take():尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。
```
## 7.现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？
```
利用jion()方法，让T2等待T1,让后让T3等待T2
```
## 8.Java 中新的 Lock 接口相对于同步代码块（synchronized block）有什么优势？如果让你实现一个高性能缓存，支持并发读取和单一写入，你如何保证数据完整性。
```
Lock比synchronized block 最大的优势是可以把写入和读单独开放上锁，可以构造更高性能的数据结构，比如条件阻塞。
```
## 9.和第5题相同
## 10.如何在 Java 中编写代码解决生产者消费者问题
```
可以采用某种机制保护生产者和消费者之间的同步
主要实现方法是     wait() / notify()方法
                 await() / signal()方法
                 BlockingQueue阻塞队列方法
```
## 11.写一段死锁代码。你在 Java 中如何解决死锁？
```
死锁发生需要必备的四个条件：
1-互斥条件，资源中必须有一个不能被共享；
2-至少有一个任务它必须持有一个资源且正在等待获取另外一个当前被别的任务持有的资源；
3-资源不能被任务抢占；
4-必须有循环等待。

代码：Suo.java

解决办法，即破坏四个条件就可
1-加锁顺序，所有的线程都按照顺序获取锁。破坏掉第二条。
2-加锁时限，在获取锁的时候加一个超时时间，如果超时，则释放已占用的锁。破坏掉第四条。
3-死锁检测。破坏掉第二条。
```
## 12..什么是原子操作？Java 中有哪些原子操作
```
原子操作：不可中断的操作。
常见的原子类：AtomicInteger、AtomicLong
```
## .既然 start() 方法，为什么我们调用 start() 方法，而不直接调用 run() 方法
```
调用 start() 方法时，它会新建一个线程然后执行 run() 方法中的代码。
如果直接调用 run() 方法并不会创建新线程，方法中的代码只会在当前调用者的线程中执行。 
```