## 4.创建线程的两种方式分别是什么？各有什么优缺点？
```
继承Thread类 
优势：编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程 
劣势：因为线程类已经继承了Thread类，所以不能再继承其他父类。 
实现Runable接口 
优势：（1）线程类只是实现了Runnable接口与Callable接口，还可以继承其他类。 
     （2）在这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、
        代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 
劣势：编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。  
```
## 5.请你简述sleep( )和wait( )有什么区别？
```
sleep() 属于Thread类，线程遇到他表示的是线程暂停一定的时间，而其他线程运行，
这其中不会释放锁对象，而到了一定的时间被暂停的线程又会自动恢复运行状态。
wait() 属于Object类，线程遇到他时，表示线程会放弃对象锁，进入等待此对象的等待锁定池，
只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
```
## 6.Java中实现线程通信的三个方法及其作用？
```
1、传统的线程通信。
在synchronized修饰的同步方法或者修饰的同步代码块中使用Object类提供的wait(),notify()和notifyAll()3个方法进行线程通信
wait():导致当前线程等待，直到其他线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程。
notify():唤醒在此同步监视器上等待的单个线程。
notifyAll():唤醒在此同步监视器上等待的所有线程。

2、使用Condition控制线程通信。
当程序使用Lock对象来保证同步，系统不存在隐式的同步监视器，只能用Condition类来控制线程通信。
await():类似于隐式同步监视器上的wait()方法，导致当前线程等待，直到其他线程调用该Condition的signal()方法或signalAll()方法来唤醒该线程。
signal():唤醒在此Lock对象上等待的单个线程。如果所有的线程都在该Lock对象上等待，则会选择唤醒其中一个线程。选择是任意性的。
signalAll():唤醒在此Lock对象上等待的所有线程，只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的线程。

3、使用阻塞队列（BlockingQueue）控制线程通信（也实现了生产者消费者模式）
put(E e):尝试把E元素放入BlockingQueue中，如果该队列的元素已满，则阻塞该线程。
take():尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。
```
## 7.现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？
```
利用jion()方法，让T2等待T1,让后让T3等待T2
```
## 8.Java 中新的 Lock 接口相对于同步代码块（synchronized block）有什么优势？如果让你实现一个高性能缓存，支持并发读取和单一写入，你如何保证数据完整性。
```
Lock比synchronized block 最大的优势是可以把写入和读单独开放上锁，可以构造更高性能的数据结构，比如条件阻塞。
```
## 未完成